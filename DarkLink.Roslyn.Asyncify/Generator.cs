using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace DarkLink.Roslyn.Asyncify;

internal record AsyncifyInfo(AttributeConfig Config, INamedTypeSymbol ExtensionType, IMethodSymbol Method);

[Generator]
public class Generator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(PostInitialize);

        var infos = AttributeConfig.Find(context.SyntaxProvider, CheckNode, CreateInfo);

        context.RegisterSourceOutput(infos, GenerateMethods);
    }

    private bool CheckNode(SyntaxNode node, CancellationToken cancellationToken)
        => node is ClassDeclarationSyntax classDeclarationSyntax && classDeclarationSyntax.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword));

    private AsyncifyInfo CreateInfo(GeneratorAttributeSyntaxContext syntaxContext, IReadOnlyList<AttributeConfig> configs, CancellationToken cancellationToken)
    {
        var config = configs.First();
        var method = config.TargetType.GetMembers(config.Method).OfType<IMethodSymbol>().First();
        return new AsyncifyInfo(config, (INamedTypeSymbol) syntaxContext.TargetSymbol, method);
    }

    private void GenerateMethods(SourceProductionContext context, AsyncifyInfo info)
    {
        var hintName = $"{info.ExtensionType.ToDisplayString()}.g.cs";
        using var writer = new CodeWriter(info);
        writer.Write();
        var source = writer.ToString();
        context.AddSource(hintName, SourceText.From(source, new UTF8Encoding(false)));
    }

    private void PostInitialize(IncrementalGeneratorPostInitializationContext context) => AttributeConfig.AddTo(context);
}

internal static class Disposable
{
    public static IDisposable Create(Action action) => new ActionDisposable(action);

    private record ActionDisposable(Action Action) : IDisposable
    {
        public void Dispose() => Action();
    }
}

internal class CodeWriter : IDisposable
{
    private readonly AsyncifyInfo info;

    private readonly StringWriter stringWriter;

    private readonly IndentedTextWriter writer;

    public CodeWriter(AsyncifyInfo info)
    {
        this.info = info;
        stringWriter = new StringWriter();
        writer = new IndentedTextWriter(stringWriter);
    }

    public void Dispose()
    {
        writer.Dispose();
        stringWriter.Dispose();
    }

    private IDisposable Reset()
    {
        var originalIndent = writer.Indent;
        writer.Indent = 0;
        return Disposable.Create(() => writer.Indent = originalIndent);
    }

    private IDisposable Scope()
    {
        writer.Indent++;
        return Disposable.Create(() => writer.Indent--);
    }

    public override string ToString() => stringWriter.ToString();

    public void Write()
    {
        writer.WriteLine("// <auto-generated />");
        writer.WriteLine();
        writer.WriteLine("using System;");
        writer.WriteLine("using System.Threading.Tasks;");
        writer.WriteLine();
        writer.WriteLine($"partial class {info.ExtensionType.Name}");
        writer.WriteLine("{");

        using (Scope())
        {
            writer.WriteLine($"public static async Task {info.Method.Name}(this Task<{info.Method.ContainingType.ToDisplayString()}> ___this)");

            using (Scope())
            {
                writer.WriteLine($"=> (await ___this).{info.Method.Name}();");
            }
        }

        writer.WriteLine("}");
    }
}
